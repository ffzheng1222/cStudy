驱动程序中的申请空间 与 释放空间
1：申请空间
	/ **********************************************************************************************************
	**	函 数 名：kzalloc
	**	函数功能：申请空间(实例化对象类)
	**	参数说明：参数1：需分配空间对象的大小
	**			  参数2：分配的标志, GFP_KERNEL------如果当前暂时没有内存,会尝试等待      
	**	返 回 值：无
	**	头 文 件：#include <linux/slab.h>
	***********************************************************************************************************/
	static inline void *kzalloc(size_t size, gfp_t flags)

2：释放空间
	/ **********************************************************************************************************
	**	带 参 宏：kfree
	**	函数功能：释放空间(内核回收资源)
	**	参数说明：参数1：kzalloc函数的返回值（一个已分配空间并初始化了的指针）     
	**	返 回 值：无
	**	头 文 件：#include <linux/slab.h>
	***********************************************************************************************************/
	#define kfree(x)


一、驱动要素
	(1)设备号
		1.> Linux内核为了区别不同的设备及设备驱动
			设备号：dev_t   32位整数
				分两个部分：
					主设备号：  设备类型
					次设备号：	标识具体的设备	
				dev_t（32位整数）：高12位为主设备号，低20位为次设备号
		2.> 申请设备号
			/ **********************************************************************************************************
			**	函 数 名：register_chrdev
			**	函数功能：申请主设备号
			**	参数说明：参数1：指定一个主设备号，当该参数为0时，系统会自动分配一个主设备号
			**			  参数2：字符串，描述该设备驱动的信息，由我们自定义
			**            参数3：文件操作对象
			**	返 回 值：返回负数，表示出错，其他根据第一个参数决定
			**			 （若第一个参数为 >0 的数，则返回自己指定的主设备号；
			**			  若第一个参数为 0 ，则返回内核自动分配的主设备号）
			**	头 文 件：#include <linux/fs.h>
			***********************************************************************************************************/
			static inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)
			/ **********************************************************************************************************
			**	函 数 名：unregister_chrdev
			**	函数功能：申请主设备号
			**	参数说明：参数1：释放register_chrdev函数申请的资源
			**			  参数2：同函数t register_chrdev 的参数2 (两函数的参数2必须保持一致)      
			**	返 回 值：无
			**	头 文 件：#include <linux/fs.h>
			***********************************************************************************************************/
			void unregister_chrdev(unsigned int major, const char * name)
			
	(2)创建设备节点（设备文件）
			当应用程序打开设备时，需要对应的设备节点，此时就需要创建设备节点
		
		两种方法创建设备节点	
				1，手动创建（命令行自行创建）
					mknod   文件名   类型   主设备号	次设备号
				2，自动创建
						第二点、详细讲解（见下面）
			
			
	(3)实现一些操作方法：
		例如：打开设备文件
			/ ************************************************************************
			**	函 数 名：
			**	函数功能：
			**  参数说明：
			**	返 回 值：
			*************************************************************************/
			int (*open) (struct inode *, struct file *);
			
			用法举例：
				int led_open(struct inode *inode, struct file *file)
				{
					printk("============%s============\n",__func__);
					return 0;
				}


				struct file_operations led_filp = 
				{
					.open = led_open,
				};
		

二、自动创建设备节点
		
		/ ************************************************************************
		**	带 参 宏：class_create
		**	宏 功 能：创建一个具体设备的类(为函数device_create服务的)
		**  参数说明：参数1：当前模块(THIS_MODULE)
		**			  参数2：字符串，具体设备类的名称
		**	返 回 值：成功：返回一个设备类的指针(把创建的这个设备的类返回驱动程序)
		**			  失败：返回 NULL
		**	头 文 件：#include <linux/device.h>
		*************************************************************************/
		#define class_create(owner, name)
		/ ************************************************************************
		**	函 数 名：class_destroy
		**	函数功能：销毁设备类(内核回收资源)
		**  参数说明：class_create宏的返回值
		**	返 回 值：无
		**	头 文 件：#include <linux/device.h>
		*************************************************************************/
		void class_destroy(struct class *cls)
		
		用法举例：
			led_dev->cls = class_create(THIS_MODULE,"led_cls");  
			if(IS_ERR(led_dev->cls)){
				printk("class_create error\n");
				ret = -EINVAL;
				goto err_unregister;
			}
		
		
		
		
		/ ************************************************************************
		**	带 参 宏：MKDEV
		**	宏 功 能：把主设备号 和 次设备号 组合成设备号
		**  参数说明：参数1：主设备号
		**			  参数2：次设备号
		**	返 回 值：返回一个设备号
		**	头 文 件：#include <linux/Kdev_t.h>
		*************************************************************************/
		#define MKDEV(ma,mi)	(((ma) << MINORBITS) | (mi))

		设备号：主设备号，次设备号		
			#define MINORBITS 20
			#define MINOMASK  (1<<MINORBITS) - 1
				
			#define MAJOR(dev) (dev) >> MINORBITS	
			#define MINOR(dev) (dev)& MINOMASK
			#define MKDEV(ma,ni) ma << MINORBITS | mi
		
		
		
		
		/ ************************************************************************
		**	函 数 名：device_create
		**	函数功能：创建设备节点（设备文件）
		**  参数说明：参数1：class_create返回的指针
		**			  参数2：父类，一般为NULL
		**			  参数3：设备号---包含主设备号(major)和次设备号(minor)
		**			  参数4：该设备的私有数据,一般为NULL
		**			  参数5：设备节点的名称
		**	返 回 值：成功：返回创建的设备的指针
		**			  失败：NULL
		**	头 文 件：#include <asm/uaccess.h>
		*************************************************************************/
		struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)
		/ ************************************************************************
		**	函 数 名：device_destroy
		**	函数功能：注销设备节点(内核回收资源)
		**  参数说明：参数1：device_create返回的指针
		**			  参数2：设备号
		**	返 回 值：无
		**	头 文 件：#include <asm/uaccess.h>
		*************************************************************************/
		void device_destroy(struct class *class, dev_t devt)

		用法举例：
			led_dev->dev = device_create(led_dev->cls, NULL, MKDEV(led_dev->led_major, 0), NULL, "led");
			if(IS_ERR(led_dev->dev))
			{
				printk("device_create error\n");
				ret = -EINVAL;
				goto err_class;
			}
		
			
三、设备初始化之物理地址映射
		看原理图----->看芯片手册--->找到寄存器对应的地址---->将地址映射到内核的虚拟空间:ioremap
		
		/ ************************************************************************
		**	带 参 宏：ioremap
		**	宏 功 能：将硬件设备寄存器对应的地址映射到内核的虚拟空间
		**  参数说明：参数1：物理地址
		**			  参数2：映射的空间大小
		**	返 回 值：返回映射的虚拟地址的起始位置
		**	头 文 件：#include <asm/io.h>
		*************************************************************************/
		#define (cooioremapkie,size)
		/ ************************************************************************
		**	函 数 名：iounmap
		**	函数功能：撤销映射硬件物理地址映射的虚拟地址(内核资源回收)
		**  参数说明：参数1：ioremap映射的虚拟地址
		**	返 回 值：无
		**	头 文 件：#include <asm/io.h>
		*************************************************************************/	
		static inline void iounmap(void *addr)
		
		用法举例：
			gpc0_conf = ioremap(0xE0200060, 8);
			if(IS_ERR(gpc0_conf))
			{
				printk("ioremap error\n");
				ret = -EINVAL;
				goto err_dev;
			}
			gpc0_dat = gpc0_conf + 1;	//此数据寄存器 与 控制寄存器 在物理地址上相差4个字节
		
		
四、应用空间的数据与内核空间中数据交互
		1、应用空间数据  --------> 内核空间的数据
			/ ************************************************************************
			**	函 数 名：copy_from_user
			**	函数功能：从应用空间获取数据
			**  参数说明：参数1：要拷贝到内核空间中的地址
			**			  参数2：用户空间的数据地址：buf的地址
			**			  参数3：拷贝数据的个数
			**	返 回 值：没有拷贝成功的数据个数，拷贝成功：返回0
			**	头 文 件：#include <asm/uaccess.h>
			*************************************************************************/
			static inline long copy_from_user(void *to,	const void __user * from, unsigned long n)
		
			用法举例：
				ret = copy_from_user(&led_dev->value, buf, size);  //获取用户空间数据
				if(ret != 0)
				{
					printk(KERN_ERR "copy_from_usererror\n");
					return -EFAULT;
				}
	
		2、内核空间的数据  --------> 应用空间数据 
			/ ************************************************************************
			**	函 数 名：copy_to_user
			**	函数功能：从内核空间获取数据
			**  参数说明：参数1：要拷贝到用户空间中的地址：buf的地址
			**			  参数2：内核空间的数据地址：
			**			  参数3：拷贝数据的个数
			**	返 回 值：没有拷贝成功的数据个数，拷贝成功：返回0
			**	头 文 件：#include <asm/uaccess.h>
			*************************************************************************/
			static inline long copy_to_user(void __user *to, const void *from, unsigned long n)			
			
			用法举例：
			ret = copy_from_user(buf, &led_dev->value, size);  //获取用户空间数据
			if(ret != 0)
			{
				printk(KERN_ERR "copy_to_user\n");
				return -EFAULT;
			}
			

五、ioctl在内核中的实现
		用于给用户空间提供更多的使用方式，比如点led灯，分别点一盏灯，也可以同时点两盏灯,一般通过发送指令实现
	  
		用户空间：
				/ ********************************************************************************************
				**	函 数 名：ioctl	
				**	函数功能：把用户空间中用户对设备的操作方法 ----> 内核空间对应的驱动程序中
				**  参数说明：参数1：应用空间打开的文件描述符
				**			  参数2：应用空间需要执行的命令
				**			  参数3：可传可不传  参数类型(int)
				**					 若传：		则表示此驱动设备不止一个(比如：2个LED灯)，传具体控制哪一个设备
				**					 若不传：	则表示此驱动设备只有一个
				**	返 回 值：成功：返回 0	
				**			  失败：返回 -1
				**	头 文 件：#include <sys/ioctl.h>
				**********************************************************************************************/
				int ioctl(int d, int request/*cmd*/, .../*unsigned long args*/);
				
		-------------------------------------------------------------------------------
		
		内核空间:
				/ ****************************************************************************
				**	函 数 名：xxx_ioctl	（驱动程序自定义实现）
				**	函数功能：把内核空间中用户对设备的     操作方法 ----> 内核空间对应的驱动程序中
				**  参数说明：参数1：内核空间打开对应的设备文件指针
				**			  参数2：应用空间 传递至 内核空间----->需要执行的命令
				**			  参数3：若用户空间传递：	则用于确定到底是驱动此驱动设备的哪一个
				**					 若用户空间不传递：	则无意义
				**	返 回 值：成功：返回 0
				**			  失败：返回 -1
				**	头 文 件：#include <asm/ioctl.h>
				******************************************************************************/
				内核原型：long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
				
				ioctl在内核中的实现框架
				long xxx_ioctl(struct file *filp, unsigned int cmd, unsigned long args);
				{			
					//区分不同的命令:cmd
					switch(cmd)
					{
						case  命令1:
									......;
									break;
						case  命令2:
									......;
									break;
						case  命令3:
									......;
									break;
						.
						.
						.
						default:
									......;
									break;
					}
				}
		
		命令定义(命令1，命令2， 命令3...)：由程序猿自定义(一般宏定义)，类型为整形
			1、可以直接定义成整数来表示命令,弊端：容易和系统中的其他命令产生冲突
					#define LED_ON  0xabcd
					#define LED_OFF 0xaabb
		
			2、用内核提供的接口来定义一个整数命令
					/ ******************************************************************************
					**	带 参 宏：_IO / _IOR / _IOW /  _IOWR
					**	宏 功 能：用内核提供的接口来定义一个整数命令
					**  参数说明：参数1：幻数，一般为字符(由自己随意确定)
					**			  参数2：为整数	（也为自己随意定义，但要保此类带参宏的参数的唯一性）
					**			  参数3：若定义:	则为应用空间ioctl函数的第3个参数的类型(int)
					**					 若为_IO：	则不需要传递
					**	返 回 值：内核会返回一个具有唯一性的整数
					**	头 文 件：#include <asm/io.h>
					********************************************************************************/
					#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
					#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
					#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
					#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
				
					应用举例：
						#define LED_NUM_ON 		_IOW('L',0x1234,int)
						#define LED_NUM_OFF		_IOW('L',0x5678,int)
						#define LED_ALL_ON 		_IO('L',0x1133)
						#define LED_ALL_OFF		_IO('L',0x2233)			
			
			
六、gpio操作方法:
		1, 直接操作gpio口对应的寄存器地址(看原理图---数据手册---获取GPIO口的地址--ioremap映射)
			*gpc0_conf &= ~(0xff<<12);
			*gpc0_conf |= (0x11<<12);
	
		2, gpio库函数的接口---只需要知道gpio口的号码即可		
			
				//头文件: #include <mach/gpio.h>
				//参数_nr----->具体控制硬件设备的引脚
			S5PV210_GPC0(_nr)------>内核封装的GPC0接口
						
			申请GPIO口的使用权------------>头文件  #include <linux/gpio.h>
						/*	参数1: 申请具体设备GPIO口----> 例如: S5PV210_GPIC0(3)	 */
						/* 	参数2: 自定义字符串----> 例如: gpc0_3_led 	*/
			gpio_request(unsigned gpio,const char * label)
			释放GPIO口的使用权------------>头文件  #include <linux/gpio.h>		
						/* 	参数1: gpio_request申请的GPIO口	 */
			gpio_free(unsigned gpio)



			将某个gpio配置成输出功能,并且直接输出高低电平
						/*	参数1: 申请具体设备GPIO口----> 例如: S5PV210_GPIC0(3)	 */
						/* 	参数2: 高电平----1;		低电平-----0	*/
			gpio_direction_output(unsigned gpio,int value)
			 将某个gpio配置成输入功能
						/*	参数1: 申请具体设备GPIO口----> 例如: S5PV210_GPIC0(3)	 */
			gpio_direction_input(unsigned gpio)


					
			获取到gpio的值
			#define gpio_get_value
			设置gpio的值
			#define gpio_set_value



			通过gpio口获取到中断号码
			#define gpio_to_irq	

			
			
			
			
			
			
			
			
			
			
			
			
