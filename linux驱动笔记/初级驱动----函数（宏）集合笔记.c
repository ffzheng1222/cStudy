
					kzalloc 					kfree
//申请空间(实例化对象类)
			/**********************************************************************************************************
			**	函 数 名：kzalloc
			**	函数功能：申请空间(实例化对象类)
			**	参数说明：参数1：需分配空间对象的大小
			**			  参数2：分配的标志, GFP_KERNEL------如果当前暂时没有内存,会尝试等待      
			**	返 回 值：无
			**	头 文 件：#include <linux/slab.h>
			***********************************************************************************************************/
		static inline void *kzalloc(size_t size, gfp_t flags)
		出错码	-ENOMEM;
//释放空间(内核回收资源)
			/**********************************************************************************************************
			**	带 参 宏：kfree
			**	函数功能：释放空间(内核回收资源)
			**	参数说明：参数1：kzalloc函数的返回值（一个已分配空间并初始化了的指针）     
			**	返 回 值：无
			**	头 文 件：#include <linux/slab.h>
			***********************************************************************************************************/
	#define kfree(x)	//参数---->kzalloc函数的返回值



					kzalloc						kfree
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					register_chrdev				unregister_candev
					register_chrdev_region		unregister_chrdev_region								
					alloc_chrdev_region

					cdev_alloc
					cdev_init		
					cdev_add
		
//第一种方法:  申请/注册主设备号
			/**********************************************************************************************************
			**	函 数 名：register_chrdev
			**	函数功能：申请主设备号
			**	参数说明：参数1：指定一个主设备号，当该参数为0时，系统会自动分配一个主设备号
			**			  参数2：字符串，描述该设备驱动的信息，由我们自定义
			**            参数3：文件操作对象
			**	返 回 值：返回负数，表示出错，其他根据第一个参数决定
			**			 （若第一个参数为 >0 的数，则返回自己指定的主设备号；
			**			  若第一个参数为 0 ，则返回内核自动分配的主设备号）
			**	头 文 件：#include <linux/fs.h>
			***********************************************************************************************************/
	static inline int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)
		出错码	-ENODEV
	//注销主设备号(内核回收资源)
			/**********************************************************************************************************
			**	函 数 名：unregister_chrdev
			**	函数功能：注销主设备号(内核回收资源)
			**	参数说明：参数1：释放register_chrdev函数申请的资源
			**			  参数2：同函数t register_chrdev 的参数2 (两函数的参数2必须保持一致)      
			**	返 回 值：无
			**	头 文 件：#include <linux/fs.h>
			***********************************************************************************************************/
	void unregister_candev(struct net_device *dev)





//第二种方法:  新的字符设备的设备号申请方法
	
	1、静态申请设备号
			/************************************************************************
			**	函 数 名：register_chrdev_region
			**	函数功能：仅仅申请一个设备号
			**  参数说明：参数1：设备号
			**			  参数2：设备的个数
			**			  参数3：(设备名)字符串(驱动的描述) ---> /proc/device(可查看)
			**	返 回 值：成功: 返回 0;	
			**			  失败: 返回 < 0
			**	头 文 件：#include <asm/uaccess.h>
			************************************************************************/
	int register_chrdev_region(dev_t from, unsigned count, const char *name)
			出错码	-EINVAL
		
	2、动态申请设备号
			/************************************************************************
			**	函 数 名：alloc_chrdev_region
			**	函数功能：仅仅申请(动态申请)一个设备号
			**  参数说明：参数1：存放设备号变量的地址
			**			  参数2：次设备号的起始标号
			**			  参数3：设备的个数
			**			  参数4：(设备名)字符串(驱动的描述) ---> /proc/device(可查看)
			**	返 回 值：成功: 返回 0	
			**			  失败: 返回 < 0
			**	头 文 件：#include <asm/uaccess.h>
			************************************************************************/
	int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)
			出错码	-EINVAL		
	
		-------------------------------------------------
//创建cdev结构体的方法：
			/************************************************************************
			**	函 数 名：cdev_alloc
			**	函数功能：分配一个struct cdev 对象空间
			**  参数说明：无
			**	返 回 值：成功: 返回申请的对象空间(指针)
			**			  失败: 返回 NULL 
			**	头 文 件：#include <linux/cdev.h>
			************************************************************************/
		struct cdev *cdev_alloc(void)
			出错码	??????????
			/************************************************************************
			**	函 数 名：cdev_init
			**	函数功能：初始化cdev中的fops
			**  参数说明：参数1：描述一个字符设备信息的指针
			**			  参数2：描述字符设备驱动中的设备操作方法的指针
			**	返 回 值：无
			**	头 文 件：#include <linux/cdev.h>
			************************************************************************/
		void cdev_init(struct cdev *cdev, const struct file_operations *fops)
			/************************************************************************
			**	函 数 名：cdev_add
			**	函数功能：将当前cdev注册到系统中
			**  参数说明：参数1：描述一个字符设备信息的指针
			**			  参数2：设备号
			**			  参数3：设备的个数
			**	返 回 值：成功：返回给内核成功注册的信息
			**			  失败：返回给内核注册失败的信息
			**	头 文 件：#include <linux/cdev.h>
			************************************************************************/
		int cdev_add(struct cdev *p, dev_t dev, unsigned count)
			出错码	-ENOMEM
		-----------------------------------------------------------------------------------

		应用举例:
		
			//1>分配一个struct cdev 对象空间
			led_dev->cdev = cdev_alloc(void);

			//2>初始化cdev中的fops
			cdev_init(led_dev->cdev, &led_filp);

			//3>将当前cdev注册到系统中
			ret = cdev_add(led_dev->cdev, led_dev->led_d, 1);
			




					register_chrdev 			unregister_candev
					register_chrdev_region		unregister_chrdev_region								
					alloc_chrdev_region

					cdev_alloc
					cdev_init		
					cdev_add
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					class_create				class_destroy



//自动创建设备类
			/************************************************************************
			**	带 参 宏：class_create
			**	宏 功 能：创建一个具体设备的类(为函数device_create服务的)
			**  参数说明：参数1：当前模块(THIS_MODULE)
			**			  参数2：字符串，具体设备类的名称
			**	返 回 值：成功：返回一个设备类的指针(把创建的这个设备的类返回驱动程序)
			**			  失败：返回 NULL
			**	头 文 件：#include <linux/device.h>
			*************************************************************************/
	#define  class_create(owner, name)
		出错码	PTR_ERR(const void * ptr)   //参数---->class_create的返回值
//销毁设备类(内核回收资源)
			/************************************************************************
			**	函 数 名：class_destroy
			**	函数功能：销毁设备类(内核回收资源)
			**  参数说明：class_create宏的返回值
			**	返 回 值：无
			**	头 文 件：#include <linux/device.h>
			*************************************************************************/
	void class_destroy(struct class *cls)




					class_create				class_destroy
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					MKDEV
					device_create				device_destroy
						



//获取设备号
			/************************************************************************
			**	带 参 宏：MKDEV
			**	宏 功 能：把主设备号 和 次设备号 组合成设备号
			**  参数说明：参数1：主设备号
			**			  参数2：次设备号
			**	返 回 值：返回一个设备号
			**	头 文 件：#include <linux/Kdev_t.h>
			*************************************************************************/
	#define MKDEV(ma,mi)	//参数1---->主设备号   参数2---->次设备号	
//创建设备节点(设备文件)
			/************************************************************************
			**	函 数 名：device_create
			**	函数功能：创建设备节点（设备文件）
			**  参数说明：参数1：class_create返回的指针
			**			  参数2：父类，一般为NULL
			**			  参数3：设备号---包含主设备号(major)和次设备号(minor)
			**			  参数4：该设备的私有数据,一般为NULL
			**			  参数5：设备节点的名称
			**	返 回 值：成功：返回创建的设备的指针
			**			  失败：NULL
			**	头 文 件：#include <asm/uaccess.h>
			*************************************************************************/
	struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)
		出错码	PTR_ERR(const void * ptr)	//参数--->device_create的返回值
//注销设备节点(内核回收资源)
			/************************************************************************
			**	函 数 名：device_destroy
			**	函数功能：注销设备节点(内核回收资源)
			**  参数说明：参数1：device_create返回的指针
			**			  参数2：设备号
			**	返 回 值：无
			**	头 文 件：#include <asm/uaccess.h>
			*************************************************************************/
	void device_destroy(struct class *class, dev_t devt)




					MKDEV
					device_create				device_destroy
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					ioremap						iounmap




//初始化硬件: 设备初始化之物理地址映射
			/************************************************************************
			**	带 参 宏：ioremap
			**	宏 功 能：将硬件设备寄存器对应的地址映射到内核的虚拟空间
			**  参数说明：参数1：物理地址
			**			  参数2：映射的空间大小
			**	返 回 值：返回映射的虚拟地址的起始位置
			**	头 文 件：#include <asm/io.h>
			*************************************************************************/
	#define ioremap(cookie,size)
			出错码	-EFAULT
//撤销映射硬件物理地址映射的虚拟地址(内核资源回收)
			/************************************************************************
			**	函 数 名：iounmap
			**	函数功能：撤销映射硬件物理地址映射的虚拟地址(内核资源回收)
			**  参数说明：参数1：ioremap映射的虚拟地址
			**	返 回 值：无
			**	头 文 件：#include <asm/io.h>
			*************************************************************************/	
	static inline void iounmap(void *addr)




					ioremap 					iounmap
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					copy_from_user				copy_to_user
						



// 从用户空间获取数据, 一般都用在驱动中写操作中---- xxx_write函数
			/************************************************************************
			**	函 数 名：copy_from_user
			**	函数功能：从应用空间获取数据
			**  参数说明：参数1：要拷贝到内核空间中的地址
			**			  参数2：用户空间的数据地址：buf的地址
			**			  参数3：拷贝数据的个数
			**	返 回 值：拷贝失败: 没有拷贝成功的数据个数，
			**			  拷贝成功：返回0
			**	头 文 件：#include <asm/uaccess.h>
			*************************************************************************/
	static inline unsigned long __must_check copy_from_user(void *to, const void __user *from, unsigned long n)
			出错码	-EFAULT
//给用户空间数据, 一般都用在驱动中读操作中---- xxx_read
			/************************************************************************
			**	函 数 名：copy_to_user
			**	函数功能：从内核空间获取数据
			**  参数说明：参数1：要拷贝到用户空间中的地址：buf的地址
			**			  参数2：内核空间的数据地址：
			**			  参数3：拷贝数据的个数
			**	返 回 值：拷贝失败: 没有拷贝成功的数据个数，
			**			  拷贝成功：返回0
			**	头 文 件：#include <asm/uaccess.h>
			*************************************************************************/
	static inline unsigned long __must_check copy_to_user(void __user *to, const void *from, unsigned long n)




					copy_from_user				copy_to_user
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					_IO
					_IOR						_IOW
					_IOWR	
					xxx_ioctl


//用内核提供的接口来定义一个整数命令
			/******************************************************************************
			**	带 参 宏：_IO / _IOR / _IOW /  _IOWR
			**	宏 功 能：用内核提供的接口来定义一个整数命令
			**  参数说明：参数1：幻数，一般为字符(由自己随意确定)
			**			  参数2：为整数	（也为自己随意定义，但要保此类带参宏的参数的唯一性）
			**			  参数3：若定义:	则为应用空间ioctl函数的第3个参数的类型(int)
			**					 若为_IO：	则不需要传递
			**	返 回 值：内核会返回一个具有唯一性的整数
			**	头 文 件：#include <asm/io.h>
			********************************************************************************/
	#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
	#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
	#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
	#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))

			/****************************************************************************
			**	函 数 名：xxx_ioctl	（驱动程序自定义实现）
			**	函数功能：把内核空间中用户对设备的     操作方法 ----> 内核空间对应的驱动程序中
			**  参数说明：参数1：内核空间打开对应的设备文件指针
			**			  参数2：应用空间 传递至 内核空间----->需要执行的命令----->上述宏
			**			  参数3：若用户空间传递：	则用于确定到底是驱动此驱动设备的哪一个
			**					 若用户空间不传递：	则无意义
			**	返 回 值：成功：返回 0
			**			  失败：返回 -1
			**	头 文 件：#include <asm/ioctl.h>
			******************************************************************************/
内核原型：long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);





					_IO
					_IOR						_IOW
					_IOWR	
					xxx_ioctl
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					S5PV210_GPC0
					gpio_request				gpio_free
					gpio_direction_output		gpio_direction_input
					gpio_get_value				gpio_set_value
					gpio_to_irq



			//头文件: #include <mach/gpio.h>
			//参数_nr----->具体控制硬件设备的引脚
S5PV210_GPC0(_nr)------>内核封装的GPC0接口
			
//申请GPIO口的使用权------------>头文件  #include <linux/gpio.h>
			/*	参数1: 申请具体设备GPIO口----> 例如: S5PV210_GPIC0(3)	 */
			/* 	参数2: 自定义字符串----> 例如: gpc0_3_led 	*/
	gpio_request(unsigned gpio,const char * label)
//释放GPIO口的使用权------------>头文件  #include <linux/gpio.h>		
			/* 	参数1: gpio_request申请的GPIO口	 */
	gpio_free(unsigned gpio)



// 将某个gpio配置成输出功能,并且直接输出高低电平
			/*	参数1: 申请具体设备GPIO口----> 例如: S5PV210_GPIC0(3)	 */
			/* 	参数2: 高电平----1;		低电平-----0	*/
	gpio_direction_output(unsigned gpio,int value)
// 将某个gpio配置成输入功能
			/*	参数1: 申请具体设备GPIO口----> 例如: S5PV210_GPIC0(3)	 */
	gpio_direction_input(unsigned gpio)


		
//获取到gpio的值
			/*	参数1: 申请具体设备GPIO口----> 例如: S5PV210_GPIC0(3)	 */
	#define gpio_get_value(unsigned gpio)
//设置gpio的值
			/*	参数1: 申请具体设备GPIO口----> 例如: S5PV210_GPIC0(3)	 */
	#define gpio_set_value(unsigned gpio)



//通过gpio口获取到中断号码
			/*	参数1: 申请具体设备GPIO口----> 例如: S5PV210_GPIC0(3)	 */
	#define gpio_to_irq(unsigned gpio)




					S5PV210_GPC0
					gpio_request				gpio_free
					gpio_direction_output		gpio_direction_input
					gpio_get_value				gpio_set_value
					gpio_to_irq
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					iminor						imajor




//通过struct file 结构体找到  struct inode 节点
	struct inode *inode = file->f_path.dentry->d_inode;


	//获取次设备号
			/************************************************************************
			**	函 数 名：iminor
			**	函数功能：从inode节点获取-------次设备号
			**  参数说明：参数1：inode节点
			**	返 回 值：次设备号
			**	头 文 件：#include <linux/fs.h>
			*************************************************************************/
	static inline unsigned iminor(const struct inode *inode)

	//获取主设备号
			/************************************************************************
			**	函 数 名：imajor
			**	函数功能：从inode节点获取-------主设备号
			**	参数说明：参数1：inode节点
			**	返 回 值：主设备号
			**	头 文 件：#include <linuux/fs.h>
			*************************************************************************/
	static inline unsigned imajor(const struct inode *inode)


	/* 
	   通过万能指针 struct file 结构体中的万能指针   void * private_data
	   能实现多个函数之间 数据共享   注意点: 传递过程中数据必须存于静态区
	*/



					iminor						imajor
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					request_irq					free_irq



//申请中断:
		irq:
			// 中断号获取: IRQ_EINT(1) 或者 去找irqs.h
		flags:
		#define IRQF_TRIGGER_NONE		0x00000000 		//内部中断触发
		#define IRQF_TRIGGER_RISING		0x00000001		//上升沿触发
		#define IRQF_TRIGGER_FALLING	0x00000002		//下降沿触发
		#define IRQF_TRIGGER_HIGH		0x00000004		//高电平触发
		#define IRQF_TRIGGER_LOW		0x00000008		//低电平触发
		
		/************************************************************************
		**	函 数 名：request_irq
		**	函数功能：申请中断
		**	参数说明：参数1：中断号
		**			  参数2：中断的处理方法irqreturn_t (*irq_handler_t)(int, void *);
		**			  参数3：中断的触发方式
		**			  参数4：表示一个字符串--自定义--/proc/interrupts
		**			  参数5：参数给第二个参数的数据
		**	返 回 值：成功: 返回	0	
		**			  失败: 返回	非0
		**	头 文 件：#include <linux/interrupt.h>
		************************************************************************/
	static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev)
		 错误码		-EBUSY
		
	//中断处理函数:
		irqreturn_t  xxx_irq_handler(int irqno, void *dev_id)
		{
			//参数1----内核自动从request_irq函数传进来的中断号
			//参数2----内核自动从request_irq函数传进来的参数
			return IRQ_HANDLED; 	//注意!!!	 中断处理函数(中断服务程序)最后一定返回IRQ_HANDLED
		}
	
		
		
//中断资源释放函数
		/************************************************************************
		**	函 数 名：free_irq
		**	函数功能：释放中断资源(不释放，下次申请中断，中断处理函数会出错)
		**	参数说明：参数1：request_irq函数申请的中断号
		**			  参数2：和request_irq中最后一个参数保持一致(request_irq函数参数5)
		**	返 回 值：无
		**	头 文 件：#include <linux/interrupt.h>
		************************************************************************/
	void free_irq(unsigned int irq, void *dev_id)



					request_irq					free_irq
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					tasklet_init				tasklet_schedule
					tasklet_kill
					

//实现中断下半部
		/************************************************************************
		**	函 数 名：tasklet_init
		**	函数功能：初始化中断下半部
		**	参数说明：参数1：中断下半部tasklet对象
		**			  参数2：中断下半部服务程序
		**			  参数3：传递给中断下半部服务程序的形参
		**	返 回 值：无
		**	头 文 件：不知道？
		************************************************************************/
	void tasklet_init(struct tasklet_struct *t,void (*func)(unsigned long), unsigned long data)
	
		/************************************************************************
		**	函 数 名：tasklet_schedule
		**	函数功能：把中断下半部tasklet对象加入到内核线程中去
		**	参数说明：参数1：中断下半部tasklet对象
		**	返 回 值：无
		**	头 文 件：不知道
		************************************************************************/
	tasklet_schedule(struct tasklet_struct * t)
	
		/************************************************************************
		**	函 数 名：tasklet_kill
		**	函数功能：销毁中断下半部tasklet对象
		**	参数说明：参数1：中断下半部tasklet对象
		**	返 回 值：无
		**	头 文 件：不知道？
		************************************************************************/
	void tasklet_kill(struct tasklet_struct * t)
	
	
					tasklet_init				tasklet_schedule
					tasklet_kill
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					init_waitqueue_head			wait_event_interruptible
					wake_up_interruptible


　
//阻塞的实现:

	//1.---->需要一个等待队列头
			typedef struct __wait_queue_head wait_queue_head_t;
			/************************************************************************
			**	带 参 宏：init_waitqueue_head
			**	宏 功 能：初始化等待队列头
			**  参数说明：参数1： 实现阻塞的等待队列头------(一个指针)
			**	返 回 值：无
			**	头 文 件：#include <linux/wait.h>
			************************************************************************/
			#define init_waitqueue_head(q)
				//init_waitqueue_head(struct wait_queue_head_t *q)
			
			
	//2.---->根据条件可以让进程进入到休眠状态
			/************************************************************************
			**	带 参 宏：wait_event_interruptible
			**	宏 功 能：根据条件可以让进程进入到休眠状态
			**  参数说明：参数1：表示等待队列头-------(注意：等待队列变量)
			**			  参数2：表示一个条件--如果为假,就在此休眠,如果为真,就不休眠
			**	返 回 值：无
			**	头 文 件：#include <linux/wait.h>
			************************************************************************/
			#define wait_event_interruptible(wq, condition)	
					//wait_event_interruptible(struct wait_queue_head_t wq, int condition)
			
		
	//3.----->资源可达的时候需要唤醒
			/************************************************************************
			**	带 参 宏：wake_up_interruptible
			**	宏 功 能：资源可达的时候需要(何以)唤醒
			**  参数说明：参数1：表示进程在休眠状态可以被中断唤醒------(一个指针)
			**	返 回 值：无
			**	头 文 件：#include <linux/wait.h>
			**		      #include <linux/sched.h>
			************************************************************************/
			#define wake_up_interruptible(x)
				//wake_up_interruptible(wait_queue_head_t *q)


//非阻塞的实现:
		在应用中设定非阻塞模式:
		int fd = open("/dev/key0", O_RDWR|O_NONBLOCK)
			
		read() 有数据就得到数据,没有数据就得到一个出错码--EAGAIN;
		-----------------------------------------------------------
		驱动:
			xxx_read
			{
				//区分阻塞还是非阻塞
				if((filp->f_flags & O_NONBLOCK) && !key_dev->have_data)
				{
					return -EAGAIN;
				}
			}		




					init_waitqueue_head 		wait_event_interruptible
					wake_up_interruptible
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					poll_wait
				
		
//将当前的等待队列头注册到vfs中
			/************************************************************************
			**	函 数 名：poll_wait
			**	函数功能：将当前的等待队列头注册到vfs中
			**	参数说明：参数1：struct file对象
			**			  参数2：等待队列头
			**			  参数3：与等待队列关联的表格
			**	返 回 值：无
			**	头 文 件：#include <linux/poll.h>
			************************************************************************/
		static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)
	
	
					poll_wait		
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					virt_to_phys				remap_pfn_range
					mmap						munmap

//虚拟地址转物理地址
			/************************************************************************
			**	带 参 宏：virt_to_phys
			**	宏 功 能：把内核中的虚拟地址转为硬件物理地址
			**  参数说明：参数1：需要转换的内核虚拟地址
			**	返 回 值：返回该虚拟地址对应的硬件物理地址
			**	头 文 件：#include<asm/memory.h>
			************************************************************************/	
		virt_to_phys((unsigned long)(x))

//将驱动中内存映射到用户空间(vma用于描述用户空间映射的需求, vma是vfs层传递过来)
			/************************************************************************
			**	函 数 名：remap_pfn_range
			**	函数功能：将驱动中内存映射到用户空间
			**	参数说明：参数1：表示需求
			**			  参数2：映射到用户空间的起始位置
			**			  参数3：被映射的物理地址的页地址
			**			  参数4：映射虚拟内存的大小
			**			  参数5：映射的权限
			**	返 回 值：无
			**	头 文 件：#include <linux/mm.h>
			************************************************************************/
		int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,
							unsigned long pfn, unsigned long size, pgprot_t prot)
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//应用空间mmap的实现	
			/************************************************************************
			**	函 数 名：mmap
			**	函数功能：将驱动中内存映射到用户空间
			**	参数说明：参数1：指定映射到用户空间的地址,一般都填NULL,由系统自动分配
			**			  参数2：映射的内存长度
			**			  参数3：对内存的访问权限PROT_EXEC,PROT_READ,PROT_WRITE
			**			  参数4：是否给其他进程映射---MAP_PRIVATE,MAP_SHARED(允许共享)
			**			  参数5：调用mmap打开的文件描述符
			**			  参数6：从内存的多少偏移量开始映射
			**	返 回 值：成功：返回	映射到用户空间的起始地址
			**			  失败：返回    MAP_FAILED (值为(void *) -1)
			**	头 文 件：#include <sys/mman.h>
			************************************************************************/
		void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);	
			/************************************************************************
			**	函 数 名：munmap
			**	函数功能：去除映射
			**	参数说明：参数1：mmap映射得到的地址
			**			  参数2：映射的内存长度
			**	返 回 值：成功：返回 	 0
			**			  失败：返回  	-1
			**	头 文 件：#include <sys/mman.h>
			************************************************************************/
		i鐨勮〃鏍